<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head><title>Debu.gs:  Inferno Part 0:  Namespaces</title><link rel="stylesheet" media="all" href="/static/stylesheet.css"></link>
<link rel="alternate" type="application/rss+xml" title="Debu.gs Blog RSS" href="http://debu.gs/blog/feed.rss"></link>
</head><body><div class="header"><h2 class="tagline">It&#39;s user error.</h2><h1><a href="/">Debu.gs</a></h1></div><hr class="stupid"></hr><div class="navbar"><div class="navlist"><h2>Navigate</h2><ul><li class="nav-entry"><a href="/">Top</a></li><li class="nav-entry"><a href="/blog/archives">All Entries</a></li><li class="nav-entry"><a href="http://debu.gs/blog/feed.rss">RSS</a></li><li class="nav-entry"><a href="/code">Code</a></li><li class="nav-entry"><a href="/about">About</a></li></ul></div><div class="navlist"><h2>GitHub</h2><ul><li class="nav-entry"><a href="http://github.com/pete/pez">pez</a></li><li class="nav-entry"><a href="http://github.com/pete/roboto">roboto</a></li><li class="nav-entry"><a href="http://github.com/pete/watts">watts</a></li><li class="nav-entry"><a href="http://github.com/pete/hoshi">hoshi</a></li><li class="nav-entry"><a href="http://github.com/pete/senga">senga</a></li><li class="nav-entry"><a href="http://github.com/pete/euler">euler</a></li></ul></div><div class="navlist"><h2>Tags</h2><ul><li class="nav-entry"><a href="/tags/awk">awk</a></li><li class="nav-entry"><a href="/tags/c">c</a></li><li class="nav-entry"><a href="/tags/code">code</a></li><li class="nav-entry"><a href="/tags/forth">forth</a></li><li class="nav-entry"><a href="/tags/historic">historic</a></li><li class="nav-entry"><a href="/tags/hoshi">hoshi</a></li><li class="nav-entry"><a href="/tags/inferno">inferno</a></li><li class="nav-entry"><a href="/tags/pez">pez</a></li><li class="nav-entry"><a href="/tags/plan9">plan9</a></li><li class="nav-entry"><a href="/tags/ruby">ruby</a></li><li class="nav-entry"><a href="/tags/site-news">site-news</a></li><li class="nav-entry"><a href="/tags/views">views</a></li><li class="nav-entry"><a href="/tags/wiki">wiki</a></li></ul></div></div><div class="content"><div class="blog-entry"><h2><a href="/entries/inferno-part-0-namespaces">Inferno Part 0:  Namespaces</a></h2><span class="byline">Pete Elmore, 2012-05-09 17:44</span><p>I&#8217;ve promised but not yet delivered on a post about getting up and running with Inferno, and doing incredible things; I&#8217;ve bloated it into a series, of which this is the introductory part.  I&#8217;m going to talk a little about namespaces, hopefully in such a way that it makes sense.  It&#8217;s a critical piece of the OS, and it one of the things that set Plan 9 and Inferno apart from what you&#8217;re running on your desktop now.</p>
<p>Inferno at times gets dismissed, and I don&#8217;t intend to evangelize per se.  I want to help close the gap between the backstory and the practice, to explain how to use Inferno and why it works the way it does.</p>
<p>I&#8217;ve got to make some excursions; please bear with me.  I&#8217;m going to talk about the evolution of the namespace, not quite in chronological order, but in ascending order of power, and then illustrate how to use Inferno&#8217;s.</p>
<h3><span class="caps">DOS</span></h3>
<p>Remember running <span class="caps">DOS</span>?  You have A: and B:, those are your floppies.  You have C:, your hard disk, and so on.  You&#8217;ve got a directory hierarchy under the drives.  (I gloss over the details somewhat.)  You can think of this as a flat, top-level, single-letter, hardware-based namespace.  One disk, one letter.</p>
<h3>Unix, Linux</h3>
<p>Unix, though, had a top-level root directory, &#8220;/&#8221;.  A root disk was mounted and other disks were mounted in subdirectories of root, subdirectories of subdirectories, wherever you felt you wanted the disk to be.  You don&#8217;t need to know what&#8217;s on which partition of what disk unless you&#8217;re putting the system together or your program has filled up a disk.  You can think of this as a hierarchical namespace, shared across the OS.</p>
<p>This is a much more flexible, powerful approach.  Applications and their users need not know or care what disk something is on.</p>
<p>Later, Unix got filesystems of a different sort:  synthetic filesystems.  /proc, for example.  Linux has /sys, and sometimes /dev is a synthetic filesystem.  There is no physical disk storing the files in these filesystems, although no program needs to know that.  The files show up in the namespace as any other file would, and programs need not even be modified to read or write files in these systems.</p>
<p>Slightly between these are filesystems that actually do represent files on disk, but not so far as the machine mounting them can prove.  <span class="caps">NFS</span>, for example, presents a remote service containing a hierarchy of files and directories.</p>
<p>Then there&#8217;s the <a href="http://fuse.sourceforge.net/"><span class="caps">FUSE</span></a> , which provides filesystems in user-space.  Speaking <span class="caps">FUSE</span> to the kernel locally and backed by whatever you wish to write a driver for, you can create filesystem servers for arbitrary synthetic filesystems without stuffing new drivers into the kernel.  (I gloss over <span class="caps">BSD</span>; fewer features seem to have made it there from Plan 9, although <a href="http://dragonflybsd.org/">DragonFly</a> has developed some interesting ideas.)</p>
<p>On the other hand, since the namespace is shared across the machine, you need to be root to modify it.  Imagine a random user mounting something atop /sbin, obscuring even the unmount command.  Per-user mounts are a minor exception, a sort of workaround that doesn&#8217;t violate the semantics:  you can mount a <span class="caps">FUSE</span> filesystem, for example, on any directory you own.  (And Linux now supports as a kernel module 9P2000, the protocol Plan 9 and Inferno speak.)</p>
<p>Previously, a filesystem could only be mounted in one place.  &#8220;Bind mounts&#8221; in Linux get you slightly more flexibility; once a filesystem (or piece of a filesystem) is <strong>somewhere</strong> in the namespace, it can put placed elsewhere with `mount &#8212;bind`.  It is a semi-recent addition, and it wasn&#8217;t until Linux 2.6.26 that a filesystem could be mounted read-write but bound read-only in a different spot.</p>
<h3>Plan 9, Inferno</h3>
<p>Plan 9 and Inferno take several large chunks of the historical Unix semantics and toss them completely out the window, by tossing out some of the core assumptions of the OS, assumptions that have been largely implicit.  I&#8217;m going to talk about Inferno, but nearly all of this also applies to (and appeared first in) Plan 9.  Wherever I say &#8220;in Inferno&#8221;, feel free to add a parenthetical &#8220;and also in Plan 9&#8221;.  The assumptions are not listed in any specific order, but have been given ordinals so that they can be referred to.</p>
<p>The first assumption to go, the easiest to break and perhaps the most obvious in retrospect, is that files and directories inside the namespace represent on-disk objects.</p>
<p>The second assumption to go is that of a one-to-one correspondence between filesystems and mountpoints.  That is to say, a given filesystem is mounted in exactly one place, and exactly one filesystem is mounted in that place.  Getting rid of this assumption means that a filesystem and the place where it is mounted are independent of each other and that any number of filesystems may be mounted on the same mountpoint.</p>
<p>The third assumption to go is that of a one-to-one correspondence between a running system and a namespace.  If changes to the namespace were seen only by a process and its children, there would be no need to protect users from changes to the namespace made by other users, and so no reason to restrict when and where a user could mount things.  The user just needs read access to the filesystem to mount.</p>
<p>Dropping these assumptions about the namespace a given process inhabits allows for a much more powerful model of a system, in ways that are not immediately obvious when taken as a whole, but which represent as large a shift as that from the <span class="caps">DOS</span> concept of a namespace to the Unix concept.</p>
<p>Those three assumptions have been broken to various degrees in Unix-like operating systems, and with varying degrees of success.  The first assumption of a given filesystem as a representation of objects on a disk has been successfully broken in Unix.  You have /proc, for example, in nearly every Unix.  <span class="caps">FUSE</span> allows users to mount filesystems, even separating them (not perfectly, of course) from other users, allowing for a sort of private namespace, almost breaking the third assumption.  Bind mounts allow for parts of the namespace to appear elsewhere in the namespace, coming somewhat close to the second, but requiring root.  Union mounts have also made it into mainstream Unix, sort of.  But, with the exception of the first assumption, the solutions are all incomplete.  What if we started from the beginning, without the Unix baggage?</p>
<p>Since the namespace is per-process (strictly speaking, any process can but does not have to fork the namespace), anyone can mount anything anywhere, or bind anything anywhere, without creating security problems.  Since a mountpoint can contain any number of mounts, all of them visible, filesystems can be overlaid on each other.  Since any filesystem may be &#8220;real&#8221; or &#8220;synthetic&#8221; provided it speaks the appropriate protocol (9P2000 in the case of Inferno), anything can be a filesystem (and everything is), and any program that interacts with files can use it.</p>
<p>A lot of things that are either hacky or distasteful suddenly disappear, by virtue of no longer being necessary.  Obviously, a lot of what we delegate to root disappears, as does sudo.  chroot disappears.  Symbolic links disappear.  A huge number of in-kernel drivers disappear.  <span class="caps">NFS</span> and /etc/exports disappear (good riddance).  `mount -o loop` disappears.  `mount &#8212;bind` disappears.  <span class="caps">FUSE</span> disappears.  sshfs disappears.  Even $<span class="caps">PATH</span> disappears, and along with it the need to be root to install software.</p>
<h3>&#8230;So?</h3>
<p>One of the things that irks me about documentation for Inferno (and Plan 9) is that there are research papers, man pages, and source code, but very few tutorial- or &#8220;howto&#8221;-style documents.  Maybe I&#8217;m spoiled by Linux, which came with a <a href="http://www.faqs.org/docs/Linux-mini/Coffee.html"><span class="caps">HOWTO</span> for making coffee</a> at least as far back as 1998.  Getting started is a bit of a task, especially if you don&#8217;t know enough about the system to use the system to investigate itself.  You jump in, there&#8217;s an unfamiliar shell that runs unfamiliar commands, and the man pages, being written as a reference, are less than helpful.</p>
<p>So I can appreciate a document aimed at addressing someone saying &#8220;So?  I&#8217;ve heard promises before.  How do I use this?&#8221; and I&#8217;m going to tie all of this together with a few concrete examples, explaining as I go.</p>
<h3>After much ado, actual things you can really type</h3>
<p>Remember all of the things that disappeared?  They&#8217;ve been each been replaced with something better, and some of them with several things that are all better.  I&#8217;m going to (for the sake of simplicity among other reasons) ignore authentication in these examples, but suffice it to say that you have your choice of authentication and encryption methods in Inferno.</p>
<h4>root privileges to mount disappear</h4>
<p>This one&#8217;s easy enough:</p>
<pre><code>bind '#p' /n/prog</code></pre>
<p>That mounts the prog filesystem (Inferno&#8217;s equivalent to the /proc filesystem) on /n/prog.  As a side note, you can manage, debug, and do all sorts of things to running processes through the /prog filesystem, just like in Unix.  The difference here is that, if you mount a remote machine&#8217;s /prog locally, you can do all of those things from where you are, without ssh, and without even having debugging tools on the remote machine.  That is, you can &#8216;kill 15&#8217; and it will kill pid 15 on the remote machine.</p>
<h4>Loopback devices and <span class="caps">FUSE</span> disappear</h4>
<p>I have a bunch of .iso files all over my computer.  Let&#8217;s say that they&#8217;re in /n/cds, and I want to mount one of them:</p>
<pre><code>; 9660srv /n/cds/dfly-i386-3.0.2_REL.iso /n/dfly
; ls /n/dfly</code></pre>
<p>Now the current process and its children can see the contents of the CD.  Nothing special needed; <a href="http://man.cat-v.org/inferno/4/dossrv">9660srv(4)&zwnj;</a> knows how to read an <span class="caps">ISO</span>-9660 filesystem on one end and speak 9P2000 on the other.</p>
<p>Inferno also ships with, for example, <a href="http://man.cat-v.org/inferno/4/tarfs">tarfs(4)&zwnj;</a>, which treats a tar archive as a read-only filesystem.</p>
<h4>In-kernel drivers disappear</h4>
<p>Well, most of them.  The ones that don&#8217;t just export a filesystem, a welcome break from ever having to ioctl() again.  The drivers provided in the kernel can be listed by looking at /dev/drivers, which is a somewhat sparse list, more sparse at least than the output of lsmod on a typical Ubuntu or even Arch install.</p>
<p>Where you would need a kernel driver to support a new filesystem in most OSs, Inferno requires no modprobe (and thus no superuser privileges) and no touching of the kernel to get a new filesystem.  You can get ext2 support (read-only) by downloading <a href="http://bitbucket.org/mjl/ext2fs">ext2fs</a> , much like how the kernel doesn&#8217;t need to know about <span class="caps">ISO</span>-9660 filesystem in the example above.  (Please do not get me started on the duplication of code involved when</p>
<h4>chroot disappears</h4>
<p>Since a process can craft a namespace for itself, anything that might be harmful for an untrusted process to see can be unmounted from the namespace, and the special system call <a href="http://man.cat-v.org/inferno/2/sys-pctl">pctl(2)&zwnj;</a> can be employed to prevent the process from mounting devices.  An extreme example which unmounts everything (and thus can do nothing but run shell builtins):</p>
<pre><code>; load std
; pctl newns
; pctl nodevs
; unmount /
; ls /
sh: ls: './ls' file does not exist</code></pre>
<p>Slightly more precision than unmounting / is needed if you want to do anything useful of course, but the idea is simple.</p>
<p>You can also, in fact, construct a temporary sandbox if you want, by mounting an in-memory filesystem on top of root:</p>
<pre><code>; mount -bc {memfs -s} /
; echo Mad with power! &gt; /asdf</code></pre>
<p>And, of course, /asdf does not appear elsewhere.  (You may want to note, though, that this only applies to newly created files.)</p>
<h4>Symlinks disappear</h4>
<p>bind takes care of this nicely by allowing you to place a directory on top of another one.  For example, I like the tinytk icon set more than the default icon set, so I bind them over the defaults before starting the window manager:</p>
<pre><code>; bind -bc /icons/tinytk /icons/tk</code></pre>
<p>You can even bind a file on top of another file:</p>
<pre><code>; echo Hello &gt; some-file
; bind some-file /NOTICE
; cat /NOTICE
Hello</code></pre>
<p>Since symlinks are not needed and not present in Inferno, the problems with cyclic filesystem references very nearly disappear.</p>
<h4>$<span class="caps">PATH</span>, $<span class="caps">LDPATH</span> and root privileges for installation disappear</h4>
<p>I hate fiddling with $<span class="caps">PATH</span>.  Vast chunks of my .bashrc are devoted to the practice of figuring out which comes first, and not adding redundant paths or paths that point at binaries for different architectures.  I have the <a href="http://swtch.com/plan9port/">Plan 9 Ports</a> installed, but don&#8217;t want the Plan 9 version of man to interfere with the Linux version, for example.</p>
<p>In Inferno, everything you want to run is in /dis (/bin in Plan 9).  If you want to run executables from elsewhere, you bind it before or after /dis.</p>
<pre><code>; bind -bc $home/dis /dis</code></pre>
<p>So, if you want to install something but can&#8217;t write to /dis, install it wherever, and bind it over /dis.  No sudo needed.  It&#8217;s the same with /lib and /module.</p>
<h4><span class="caps">NFS</span> disappears</h4>
<p>I&#8217;m going to ignore authentication (the -A flag does this) and encryption for now, so we&#8217;re going to just export something that doesn&#8217;t matter:  <a href="http://man.cat-v.org/inferno/4/memfs">memfs(4)&zwnj;</a> again.  The first machine:</p>
<pre><code>; mount -c {memfs -s} /n/mem
; echo something &gt; /n/mem/asdf
; listen -A 'tcp!*!1234' { export /n/mem &amp; }</code></pre>
<p>The second machine:</p>
<pre><code>; mount -A 'tcp!thefirstmachine!1234' /n/remotememfs
; cat /n/remotememfs/asdf
something</code></pre>
<p>Since most file-serving commands can be instructed to communicate over stdin/stdout rather than staking out a mountpoint, the filesystem need not even be mounted locally to be available to the network:</p>
<pre><code>; styxlisten -A 'tcp!*!1234' {memfs -s}</code></pre>
<p>And on the second machine:</p>
<pre><code>; mount -Ac 'tcp!thefirstmachine!1234' /n/remotememfs</code></pre>
<p>The <a href="http://man.cat-v.org/inferno/1/listen">listen(1) and dial(1) commands</a> act as convenient wrappers around interactions with the /net filesystem, which is the interface to the network in Inferno.  Sockets are handled by the <span class="caps">BSD</span> sockets library (with accompanying system calls) in Unix, and are significantly trickier to use.  You can think of listen and dial as analogous to netcat.  styxlisten is the same, but expects to speak the 9P2000 protocol (referred to as Styx before its adoption in Plan 9) instead of plain bytes.</p>
<h3>Powerful primitives mean never having to say you&#8217;re sorry</h3>
<p>All of this is accomplished with a few brief commands which are themselves thin wrappers around Inferno&#8217;s syscalls.  You have <a href="http://man.cat-v.org/inferno/1/bind">bind(1), mount(1), and unmount(1)&zwnj;</a>.  If you want introspection <a href="http://man.cat-v.org/inferno/1/ns">ns(1)&zwnj;</a> is well-designed.</p>
<p>Every OS-level object being represented as a filesystem means that programs like cat, sed, and echo can be used to, for example, access the network, using <a href="http://man.cat-v.org/inferno/3/ip">the ip(3) filesystem</a> .  <a href="http://man.cat-v.org/inferno/4/ftpfs">ftpfs(4)&zwnj;</a> lets you ls and cp without using an interactive client, which means it&#8217;s easier to script, no piping into the <span class="caps">FTP</span> client, and in fact, no need for your script to even realize it is talking to an <span class="caps">FTP</span> server rather than any other file on disk.  <a href="http://bitbucket.org/mjl/zipfs">zipfs</a> lets you mount a zip file.  Combining them, you can mount an <span class="caps">ISO</span> that is inside a zip file that is on an <span class="caps">FTP</span> server, and then copy some files out of it.</p>
<h3>Somewhere in the future</h3>
<p>We&#8217;ve already hit an interesting spot.  A large chunk of the population owns at least a laptop and a smartphone, and of them, a large chunk also owns a desktop, has a work computer, has a tablet, etc.  In the heyday of Unix&#174;, there was one computer and many users.  It seems to be stating the obvious, but we&#8217;re rapidly approaching a point where the common case is one user with many computers rather than vice versa.</p>
<p>Managing all of the computing resources (disk and <span class="caps">CPU</span>, particularly) is already a pain.  Syncing files, syncing contacts, etc.  If your phone hasn&#8217;t the computes to process something, you have to go to your desktop (physically or by means of ssh).  If you want to watch a movie on your phone, you have to copy it over.  What&#8217;s your solution to reading an article on your phone and then deciding you&#8217;d rather read it on your laptop?  Send an email or IM yourself?  (Still better than DBus, but that is a digression.)</p>
<p>I don&#8217;t see this as sustainable.  The stopgap is handing all of your data to Google, Facebook, or whatever &#8220;cloud&#8221; service, but that solution leaves much to be desired (and enumerating the reasons is another digression).</p>
<p>A software solution to the problem of managing computing resources and getting all of these machines (local and remote) to cooperate is inevitable.  At least for the time being, I see Inferno as the best candidate for a platform that makes this happen.  That may not go all the way to explaining why I&#8217;m suddenly in love with the system, but it should at least go part of the way.</p>
<h3>Next on the menu</h3>
<p>This barely scratches the surface.  &#8220;Everything is a filesystem&#8221; is only one of the big ideas built into Inferno.</p>
<p>I&#8217;ve written a pile of code for Limbo (a predecessor of <a href="http://golang.org/">Go</a> and very similar) and Inferno&#8217;s brilliant <a href="http://man.cat-v.org/inferno/1/sh">sh(1)&zwnj;</a>, by far the nicest shell I have ever used.  I&#8217;m sorting out some authentication problems with clustering the machines in my house and plan to document how to build an Inferno cluster here, with some map-reduce examples.</p>
<p>I won&#8217;t write much about Limbo; plenty has been written already, and it is easy enough to get started writing code.  <a href="http://doc.cat-v.org/inferno/4th_edition/limbo_language/descent">Brian Kernighan&#8217;s article</a> is a great place to start, Dennis M. Ritchie (requiem in pax) has written <a href="http://doc.cat-v.org/inferno/4th_edition/limbo_language/limbo">a somewhat more formal overview</a>, and <a href="http://doc.cat-v.org/inferno/books/inferno_programming_with_limbo/">Inferno Programming with Limbo</a> is a good reference.</p>
<p>I&#8217;d like to write some about the shell, mostly in the form of examples.  If you are interested but do not want to wait, the <a href="http://www.vitanuova.com/inferno/papers/sh.html">article written by the author of the shell</a> is a great introduction, and I have a <a href="https://github.com/pete/euler/blob/master/infernosh/031.sh">solution on Github</a> for <a href="http://projecteuler.net/index.php?section=problems&amp;id=31">my favorite Project Euler problem</a> which should serve as a fun example of doing math in the shell.  It may look a bit messy; after all, the shell is not for math.  But comparing it to the roughly equivalent <a href="https://github.com/pete/euler/blob/master/bash/031.sh">bash solution</a> (including the timing information) is illuminating.</p>
<p>I&#8217;m tempted to write a comparison between <span class="caps">BEAM</span> and Dis, Inferno&#8217;s VM, since there are some very close similarities (e.g., message-passing, cheap concurrency, a secure VM) and some interesting differences (the type system, Inferno&#8217;s channels versus Erlang&#8217;s messages, the speed difference between the two VMs, Inferno&#8217;s sh versus the Erlang shell, and the language choice in Inferno versus on <span class="caps">BEAM</span>).  I think that might tend towards evangelism, though.</p>
<p>So, expect some time later a guided tour of the shell and a brief introduction to building a cluster out of scattered Inferno VMs, although not necessarily in that order, and there is a non-zero probability a comparison of <span class="caps">BEAM</span> and Dis will show up here at some point, although that is slightly less likely.</p>
<h4>An aside about my favorite Project Euler problem</h4>
<p>It&#8217;s number 31.  The algorithm is easy to understand and implementations can range from slow to fast, and the problem seems to lend itself, like <a href="http://99-bottles-of-beer.net/">99 Bottles of Beer on the Wall</a> , to giving a tour of the language, so it&#8217;s usually one of the first problems I do in any given language.</p>
<h3>Update for clarification</h3>
<p>I&#8217;ve gotten a question about mountpoint conflicts.  The -a and -b flags passed to mount and bind are for mounting &#8220;after&#8221; or &#8220;before&#8221; whatever filesystems are already present on the mountpoint.  You can think of the directories as linked lists, and the -a and -b options append or prepend, respectively.  I&#8217;ll demonstrate with an example:</p>
<pre><code>; mkdir /tmp/a
; mkdir /tmp/b
; echo 'a' &gt; /tmp/a/foo
; echo 'b' &gt; /tmp/b/foo
; bind /tmp/a /n/dasha
; bind -ac /tmp/b /n/dasha
; lc /n/dasha
foo foo
; cat /n/dasha/foo
a
; bind /tmp/a /n/dashb
; bind -bc /tmp/b /n/dashb
; cat /n/dashb/foo
b</code></pre>
<h3>Translations</h3>
<p><a href="http://habrahabr.ru/post/146076/">Russian translation</a> by <a href="http://powerman.name/">Alex Efros</a>.</p><p class="tags">Tags:  <a href="/tags/historic">historic</a> <a href="/tags/inferno">inferno</a> </p><hr></hr><a href="/entries/plan-9-and-inferno" style="float: left;">&lt;&lt; Previous: &quot;Plan 9 and Inferno&quot;</a><br style="clear: all;">
<a href="/entries/inferno-part-1-shell" style="float: right;">Next: &quot;Inferno Part 1:  Shell&quot; &gt;&gt;</a><br style="clear: all;">
</div></div><br style="clear: both;">
<div class="footer"><span class="contact">					Contact:  pete at debu dot gs
</span><span class="phrases">Liberae sunt nostrae cogitationes.</span><br style="clear: both;">
</div></body></html>